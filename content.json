{"meta":{"title":"薛之豪","subtitle":"随笔,个人博客","description":"我就想装逼写写","author":"Fatty","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SpringDataJPA之@Query with LIKE(JPA模糊查询)","slug":"SpringDataJPA之@Query with LIKE(JPA模糊查询)","date":"2019-09-18T02:59:27.000Z","updated":"2019-09-18T03:09:07.527Z","comments":false,"path":"2019/09/18/SpringDataJPA之@Query with LIKE(JPA模糊查询)/","link":"","permalink":"http://yoursite.com/2019/09/18/SpringDataJPA之@Query with LIKE(JPA模糊查询)/","excerpt":"","text":"需求遇到了这样一个需求，给一个输入框，这个输入款呢可以输入一个店铺名或者手机号码搜索。 若输入店铺名，则采用模糊搜索，若输入手机号码则精确搜索 SQL 语句不难，一个参数包含两种可能，用一个 or 连接即可 问题可遇到一个骚问题，单独模糊搜索时，有内容输入，加上 or mobile = ？1 后却没有内容，在Navicat测试SQL语句也没啥毛病。 看了半天额SQL没有头绪，毕竟没写错，于是让大佬帮忙看了一下，他说，看一下控制台的SQL语句打印。 发现 like 的「%」消失了。我看着其他的SQL语句写没什么问题，于是上网查了一下，用一个 「CONCAT」拼接即可。 如：like CONCAT （‘%’，？1，’%‘） 原因&amp;解决为什么会这样呢？ 原来，对于JPA来说，like查询是不友好的，像这种 like ‘%？1%’ 很难查出东西的。 所以 CONCAT函数来帮忙，用 like CONCAT(‘%’,?1,’%’) 进行拼接，核心就是 mysql 的concat 函数，CONCAT（）函数用于将多个字符串连接成一个字符串，是最重要的mysql函数之一","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}]},{"title":"Map 的灵异事件，get 不到值的 Map","slug":"Map 的灵异事件，get 不到值的 Map","date":"2019-09-11T08:45:05.000Z","updated":"2019-09-11T08:53:06.727Z","comments":false,"path":"2019/09/11/Map 的灵异事件，get 不到值的 Map/","link":"","permalink":"http://yoursite.com/2019/09/11/Map 的灵异事件，get 不到值的 Map/","excerpt":"","text":"都说开发五分钟，bug 两小时，今天还真的遇到了。 现象一般来说，map 作为一种 key-value 的存储结构，当然我采用 HashMap 方式实现。 今天遇到一个问题，明明去数据库中用一组 id 去拿数据，然后封装在 map 返回，但是根据对应的 key 去找，却又是没有数据。 于是 debug 去调试，发现还跳过了 map.get(id) 的数据，有点奇怪，于是重新打包，编译，打日志都没有数据出来。 我静下心看着 IDEA 给的不明显提示，这才焕然大悟，原来我封装的时候，key 是 String 类型。 而去 map 取数据的时候，是 Long 类型，难怪找不到，尽管值是一样。 分析先说说 HashMap,它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。 如果需要满足线程安全，可以用 Collections 的 synchronizedMap方法使HashMap具有线程安全的能力，或者使用 ConcurrentHashMap。 之前封装是因为调用了 put 方法，但是不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。 原因所以最先调用 Hash 算法计算出 key 的 hash 值，这里要分 JDK 1.7 和 1.8 ，感兴趣的可以自己去找资料看。 因为类型不同，比如 Long 和 String 不同，哪怕值看起来一样，最终计算出来的 key 是不同的！！！","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://yoursite.com/tags/工作/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/笔记/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-10T09:15:33.963Z","updated":"2019-09-10T09:15:33.964Z","comments":true,"path":"2019/09/10/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}